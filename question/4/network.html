<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>✨ 从输入 URL 到看到页面发生的全过程 | 子文</title>
    <meta name="generator" content="VuePress 1.7.1">
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?1cda0c3a27ed754d6344dcce0e142e04";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico">
    <link rel="dns-prefetch" href="//f1g1ns1.dnspod.net">
    <meta name="description" content="前端基础笔记、前端进阶、大前端、JavaScript">
    <meta name="baidu-site-verification" content="C7pbYsRSpU">
    <meta name="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
    <meta name="author" content="ziwen,okziwen@foxmail.com">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="ziwen">
    
    <link rel="preload" href="/assets/css/0.styles.51b25817.css" as="style"><link rel="preload" href="/assets/js/app.eb836ae3.js" as="script"><link rel="preload" href="/assets/js/2.ae751d9e.js" as="script"><link rel="preload" href="/assets/js/41.36a1ba26.js" as="script"><link rel="prefetch" href="/assets/js/10.8f825347.js"><link rel="prefetch" href="/assets/js/11.597d2775.js"><link rel="prefetch" href="/assets/js/12.e2e55ac4.js"><link rel="prefetch" href="/assets/js/13.b03fac96.js"><link rel="prefetch" href="/assets/js/14.0aa3e23e.js"><link rel="prefetch" href="/assets/js/15.3d86c8e4.js"><link rel="prefetch" href="/assets/js/16.629ad7d5.js"><link rel="prefetch" href="/assets/js/17.0c74553e.js"><link rel="prefetch" href="/assets/js/18.571f7e93.js"><link rel="prefetch" href="/assets/js/19.7d9e96d1.js"><link rel="prefetch" href="/assets/js/20.39d2e0b3.js"><link rel="prefetch" href="/assets/js/21.43009c00.js"><link rel="prefetch" href="/assets/js/22.ac4d6a08.js"><link rel="prefetch" href="/assets/js/23.b5191e81.js"><link rel="prefetch" href="/assets/js/24.efb959dd.js"><link rel="prefetch" href="/assets/js/25.19744ba8.js"><link rel="prefetch" href="/assets/js/26.4ae69b3f.js"><link rel="prefetch" href="/assets/js/27.404fa40f.js"><link rel="prefetch" href="/assets/js/28.00dc2408.js"><link rel="prefetch" href="/assets/js/29.c2cd1e1f.js"><link rel="prefetch" href="/assets/js/3.d7f43caa.js"><link rel="prefetch" href="/assets/js/30.2a8d59ae.js"><link rel="prefetch" href="/assets/js/31.1e1848a4.js"><link rel="prefetch" href="/assets/js/32.5513e776.js"><link rel="prefetch" href="/assets/js/33.cf2fc24e.js"><link rel="prefetch" href="/assets/js/34.87974ea8.js"><link rel="prefetch" href="/assets/js/35.7598f0c6.js"><link rel="prefetch" href="/assets/js/36.252697f9.js"><link rel="prefetch" href="/assets/js/37.63a165fc.js"><link rel="prefetch" href="/assets/js/38.f9bca2e7.js"><link rel="prefetch" href="/assets/js/39.95502901.js"><link rel="prefetch" href="/assets/js/4.51636a74.js"><link rel="prefetch" href="/assets/js/40.0644537e.js"><link rel="prefetch" href="/assets/js/42.bd3229bb.js"><link rel="prefetch" href="/assets/js/43.7deebcbc.js"><link rel="prefetch" href="/assets/js/44.4ce2bb70.js"><link rel="prefetch" href="/assets/js/45.4bba0068.js"><link rel="prefetch" href="/assets/js/46.02abbf2b.js"><link rel="prefetch" href="/assets/js/47.bc0b6150.js"><link rel="prefetch" href="/assets/js/48.ee3c5188.js"><link rel="prefetch" href="/assets/js/49.d4fb47e1.js"><link rel="prefetch" href="/assets/js/5.19a76e31.js"><link rel="prefetch" href="/assets/js/50.081f62bb.js"><link rel="prefetch" href="/assets/js/51.cd149d5c.js"><link rel="prefetch" href="/assets/js/52.026ea95e.js"><link rel="prefetch" href="/assets/js/53.943d6d12.js"><link rel="prefetch" href="/assets/js/54.39c6e7fe.js"><link rel="prefetch" href="/assets/js/55.6c79d6ef.js"><link rel="prefetch" href="/assets/js/56.7f3f674e.js"><link rel="prefetch" href="/assets/js/6.8e072023.js"><link rel="prefetch" href="/assets/js/7.f9c24c6d.js"><link rel="prefetch" href="/assets/js/8.5930276f.js"><link rel="prefetch" href="/assets/js/9.123f2c7c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.51b25817.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/Javascript.gif" alt="子文" class="logo"> <span class="site-name can-hide">子文</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/think/" class="nav-link">
  周边
</a></div><div class="nav-item"><a href="/question/" class="nav-link router-link-active">
  笔记(更新中...)
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/think/" class="nav-link">
  周边
</a></div><div class="nav-item"><a href="/question/" class="nav-link router-link-active">
  笔记(更新中...)
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目工程篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>网络篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/question/4/network.html" aria-current="page" class="active sidebar-link">✨ 从输入 URL 到看到页面发生的全过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/question/4/network.html#最新修改" class="sidebar-link">##最新修改##</a></li><li class="sidebar-sub-header"><a href="/question/4/network.html#_1-浏览器查找当前-url-是否存在缓存。" class="sidebar-link">1. 浏览器查找当前 URL 是否存在缓存。</a></li><li class="sidebar-sub-header"><a href="/question/4/network.html#_2-解析-url-对应的-ip-地址" class="sidebar-link">2. 解析 URL 对应的 IP 地址</a></li><li class="sidebar-sub-header"><a href="/question/4/network.html#_3-tcp-建立连接-三次握手" class="sidebar-link">3. TCP 建立连接（三次握手）</a></li><li class="sidebar-sub-header"><a href="/question/4/network.html#_4-http-发起请求、服务器处理请求、浏览器接收-http-响应" class="sidebar-link">4. HTTP 发起请求、服务器处理请求、浏览器接收 HTTP 响应</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/question/4/network.html#http-请求" class="sidebar-link">HTTP 请求</a></li><li class="sidebar-sub-header"><a href="/question/4/network.html#请求-响应实体" class="sidebar-link">请求/响应实体</a></li></ul></li><li class="sidebar-sub-header"><a href="/question/4/network.html#_5-浏览器解析渲染页面" class="sidebar-link">5. 浏览器解析渲染页面</a></li><li class="sidebar-sub-header"><a href="/question/4/network.html#_6-tcp-关闭连接-四次挥手" class="sidebar-link">6. TCP 关闭连接（四次挥手）</a></li><li class="sidebar-sub-header"><a href="/question/4/network.html#端口" class="sidebar-link">端口</a></li></ul></li><li><a href="/question/4/response.html" class="sidebar-link">✨ Response Header</a></li><li><a href="/question/4/kuayu.html" class="sidebar-link">跨域</a></li><li><a href="/question/4/tcp.html" class="sidebar-link">TCP 协议</a></li><li><a href="/question/4/udp.html" class="sidebar-link">UDP 协议</a></li><li><a href="/question/4/https.html" class="sidebar-link">Https</a></li><li><a href="/question/4/browsercache.html" class="sidebar-link">浏览器缓存</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="✨-从输入-url-到看到页面发生的全过程"><a href="#✨-从输入-url-到看到页面发生的全过程" class="header-anchor">#</a> ✨ 从输入 URL 到看到页面发生的全过程</h1> <h2 id="最新修改"><a href="#最新修改" class="header-anchor">#</a> ##最新修改##</h2> <blockquote><p>最近看了李兵老师讲解浏览器的文章，对从输入 URL 到看到页面发生的全过程这个问题有了更深层次的认知，总结如下：</p></blockquote> <img src="/img/question/network/urltoview.png" alt="从输入 URL 到看到页面发生的全过程" title="从输入 URL 到看到页面发生的全过程" class="zoom-custom-imgs"> <blockquote><p>以前的浅显认知</p></blockquote> <ol><li>浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期。</li> <li>DNS 解析 URL 对应的 IP。</li> <li>根据 IP 建立 TCP 连接（三次握手）。</li> <li>HTTP 发起请求。</li> <li>服务器处理请求，浏览器接收 HTTP 响应。</li> <li>浏览器解析渲染页面。</li> <li>关闭 TCP 连接（四次挥手）。</li></ol> <h2 id="_1-浏览器查找当前-url-是否存在缓存。"><a href="#_1-浏览器查找当前-url-是否存在缓存。" class="header-anchor">#</a> 1. 浏览器查找当前 URL 是否存在缓存。</h2> <details class="custom-block details open tip"><summary>点击查看</summary><p>浏览器首先查询当前 URL 是否有缓存,有的话,再查询是否过期,没过期则读缓存.过期了则访问 web 服务器。</p> <p><strong><a href="https://ufojs.com/question/4/browsercache.html" target="_blank" rel="noopener noreferrer">重点：浏览器缓存<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></p></details><h2 id="_2-解析-url-对应的-ip-地址"><a href="#_2-解析-url-对应的-ip-地址" class="header-anchor">#</a> 2. 解析 URL 对应的 IP 地址</h2> <details class="custom-block details open tip"><summary>点击查看</summary><ol><li>浏览器查看自己的 DNS 缓存是否存在。</li> <li>如果没找到 DNS 缓存，浏览器会接着查找本地的 hosts 文件中是否有这个网址与某个 IP 的映射关系，如果有就调用这个映射 IP，完成域名解析。</li> <li>如果 hosts 也没有找到，则会在操作系统缓存中查找本地的 DNS 解析器缓存，如果找到则返回。</li> <li>如果操作系统本地没找到，则会在路由器缓存中进行查找，如果找到则返回。</li> <li>如果还是没找到，则会通过运营商的 DNS 域名解析服务拿到 IP 地址。</li></ol></details><h2 id="_3-tcp-建立连接-三次握手"><a href="#_3-tcp-建立连接-三次握手" class="header-anchor">#</a> 3. TCP 建立连接（三次握手）</h2> <details class="custom-block details open tip"><summary>点击查看</summary><p>如下图所示，tcp 建立连接的过程：
<img src="/img/question/network/tcp3.png" alt="tcp" title="tcp" class="zoom-custom-imgs"></p> <ul><li><p>第一次握手</p> <ul><li><code>SYN = 1</code>， <code>seq(client) = x</code>
客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <code>SYN-SENT</code> 状态。</li></ul></li> <li><p>第二次握手</p> <ul><li><code>SYN = 1</code>，<code>ACK = x + 1</code>，<code>seq(server) = y</code>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入<code>SYN-RECEIVED</code> 状态</li></ul></li> <li><p>第三次握手</p> <ul><li><code>ACK = y + 1</code>，s <code>seq(client) = y + 1</code>
客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 <code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态，此时连接建立成功。</li></ul></li></ul> <h4 id="为什么是三次握手-二次-四次不行"><a href="#为什么是三次握手-二次-四次不行" class="header-anchor">#</a> 为什么是三次握手？二次，四次不行？</h4> <ul><li><p>第一次：</p> <blockquote><p>Client 什么都不能确认</p> <p>Server 确认了对方发送正常</p></blockquote></li> <li><p>第二次</p> <blockquote><p>Client 确认：自己发送/接收正常，对方发送/接收正常</p> <p>Server 确认：自己接收正常 ，对方发送正常</p></blockquote></li> <li><p>第三次</p> <blockquote><p>Client 确认：自己发送/接收正常， 对方发送/接收正常</p> <p>Server 确认：自己发送/接收正常，对方发送/接收正常</p></blockquote></li></ul> <p><strong>所以通过三次握手确认双方收发功能都正常，二次无法确认，四次也可以但是显得比较多余。</strong></p></details><h2 id="_4-http-发起请求、服务器处理请求、浏览器接收-http-响应"><a href="#_4-http-发起请求、服务器处理请求、浏览器接收-http-响应" class="header-anchor">#</a> 4. HTTP 发起请求、服务器处理请求、浏览器接收 HTTP 响应</h2> <details class="custom-block details open tip"><summary>点击查看</summary><h3 id="http-请求"><a href="#http-请求" class="header-anchor">#</a> HTTP 请求</h3> <ul><li>完整的 HTTP 请求包含请求行、请求头、请求体三部分。</li></ul> <img src="/img/question/network/http1.png" alt="http" title="http" class="zoom-custom-imgs"> <ul><li>服务器收到浏览器发送的 HTTP 请求之后，会将收到的 HTTP 报文封装成 HTTP 的 Request 对象，并通过不同的 web 服务器进行处理，处理完的结果以 HTTP 的 Response 对象返回，主要包括状态码、响应头、响应报文三个部分。</li> <li>完整的 HTTP 请求报文一般包括：通用头部、请求/响应头部、请求/响应体</li></ul> <h4 id="通用头部"><a href="#通用头部" class="header-anchor">#</a> 通用头部</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//General</span>

Request Url<span class="token operator">:</span> 请求的web服务器地址

Request Method<span class="token operator">:</span> 请求方式
（<span class="token constant">GET</span>、<span class="token constant">POST</span>、<span class="token constant">OPTIONS</span>、<span class="token constant">PUT</span>、<span class="token constant">HEAD</span>、<span class="token constant">DELETE</span>、<span class="token constant">CONNECT</span>、<span class="token constant">TRACE</span>）

Status Code<span class="token operator">:</span> 请求的返回状态码，如<span class="token number">200</span>代表成功

Remote Address<span class="token operator">:</span> 请求的远程服务器地址（会转为<span class="token constant">IP</span>）

Referrer Policy<span class="token operator">:</span> <span class="token punctuation">(</span>引用策略<span class="token punctuation">)</span> <span class="token function">用来监管哪些访问来源信息</span> <span class="token punctuation">(</span><span class="token constant">IE</span>暂不支持<span class="token punctuation">)</span>

</code></pre></div><h4 id="请求-响应头部"><a href="#请求-响应头部" class="header-anchor">#</a> 请求/响应头部</h4> <p><strong>常用的请求头部分：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code>
Accept<span class="token operator">:</span> 接收类型，表示浏览器支持的<span class="token constant">MIME</span>类型
（对标服务端返回的Content<span class="token operator">-</span>Type）

Accept<span class="token operator">-</span>Encoding<span class="token operator">:</span> 浏览器支持的压缩类型<span class="token punctuation">,</span>如gzip等<span class="token punctuation">,</span>超出类型不能接收

Content<span class="token operator">-</span>Type：客户端发送出去实体内容的类型

Cache<span class="token operator">-</span>Control<span class="token operator">:</span> 指定请求和响应遵循的缓存机制，如no<span class="token operator">-</span>cache

If<span class="token operator">-</span>Modified<span class="token operator">-</span>Since：对应服务端的Last<span class="token operator">-</span>Modified，用来匹配看文件是否变动，只能精确到<span class="token number">1</span>s之内，http1<span class="token punctuation">.</span><span class="token number">0</span>中

Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1<span class="token punctuation">.</span><span class="token number">0</span>，而且是服务端时间

Max<span class="token operator">-</span>age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1<span class="token punctuation">.</span><span class="token number">1</span>中

If<span class="token operator">-</span>None<span class="token operator">-</span>Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1<span class="token punctuation">.</span><span class="token number">1</span>中

Cookie<span class="token operator">:</span> 有cookie并且同域访问时会自动带上

Connection<span class="token operator">:</span> 当浏览器与服务器通信时对于长连接如何进行处理<span class="token punctuation">,</span>如keep<span class="token operator">-</span>alive

Host：请求的服务器<span class="token constant">URL</span>

Origin：最初的请求是从哪里发起的（只会精确到端口）<span class="token punctuation">,</span>Origin比Referer更尊重隐私

Referer：该页面的来源<span class="token constant">URL</span><span class="token punctuation">(</span>适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段<span class="token punctuation">)</span>

User<span class="token operator">-</span>Agent：用户客户端的一些必要信息，如<span class="token constant">UA</span>头部等

</code></pre></div><p><strong>常用的响应头部分：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token operator">:</span> 服务器端允许的请求Headers

Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token operator">:</span> 服务器端允许的请求方法

Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> 服务器端允许的请求Origin头部（譬如为<span class="token operator">*</span>）

Content<span class="token operator">-</span>Type：服务端返回的实体内容的类型

Date：数据从服务器发送的时间

Cache<span class="token operator">-</span>Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档

Last<span class="token operator">-</span>Modified：请求资源的最后修改时间

Expires：应该在什么时候认为文档已经过期<span class="token punctuation">,</span>从而不再缓存它

Max<span class="token operator">-</span>age：客户端的本地资源应该缓存多少秒，开启了Cache<span class="token operator">-</span>Control后有效

ETag：请求变量的实体标签的当前值

Set<span class="token operator">-</span>Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端

Keep<span class="token operator">-</span>Alive：如果客户端有keep<span class="token operator">-</span>alive，服务端也会有响应（如timeout<span class="token operator">=</span><span class="token number">500</span>）

Server：服务器的一些相关信息

</code></pre></div><ul><li>一般来说，请求头部和响应头部是匹配分析的。<br></li> <li>比如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错。<br></li> <li>比如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误。<br></li> <li>比如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应。</li></ul> <h3 id="请求-响应实体"><a href="#请求-响应实体" class="header-anchor">#</a> 请求/响应实体</h3> <p>请求实体中会将一些需要的参数都放入进入（用于 post 请求）。</p> <p>譬如实体中可以放参数的序列化形式（a=1&amp;b=2 这种），或者直接放表单对象（Form Data 对象，上传时可以夹杂参数以及文件），等等。</p> <p>一般响应实体中，就是放服务端需要传给客户端的内容。</p> <p>一般现在的接口请求时，实体中就是对于的信息的 json 格式，而像页面请求这种，里面就是直接放了一个 html 字符串，然后浏览器自己解析并渲染。</p> <img src="/img/question/network/httpstatus.png" alt="https" title="https" class="zoom-custom-imgs"></details><h2 id="_5-浏览器解析渲染页面"><a href="#_5-浏览器解析渲染页面" class="header-anchor">#</a> 5. 浏览器解析渲染页面</h2> <details class="custom-block details open tip"><summary>点击查看</summary><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p> <blockquote><ol><li>解析 HTML，构建 DOM 树</li> <li>解析 CSS，生成 CSS 规则树</li> <li>合并 DOM 树和 CSS 规则，生成 render 树</li> <li>布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算</li> <li>绘制 render 树（paint），绘制页面像素信息</li> <li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上</li></ol></blockquote> <p>reflow：也称作 layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为 reflow。</p> <p>repaint：中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候(例如：背景色，边框颜色，文字颜色等)，此时只需要应用新样式绘制这个元素就可以了。</p> <ol><li><p>根据 HTML 解析 DOM 树</p> <ul><li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li> <li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li></ul></li> <li><p>根据 CSS 解析生成 CSS 规则树</p> <ul><li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li> <li>浏览器在 CSS 规则树生成之前不会进行渲染。</li></ul></li> <li><p>结合 DOM 树和 CSS 规则树，生成渲染树</p> <ul><li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li> <li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li></ul></li> <li><p>根据渲染树计算每一个节点的信息（布局）</p> <ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸。</li> <li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul></li> <li><p>根据计算好的信息绘制页面</p> <ul><li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li> <li>重绘 <code>repaint</code>：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li> <li>回流 <code>reflow</code>：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。
<img src="/img/question/network/domrender.png" alt="domrender" title="domrender" class="zoom-custom-imgs"></li></ul></li></ol></details><h2 id="_6-tcp-关闭连接-四次挥手"><a href="#_6-tcp-关闭连接-四次挥手" class="header-anchor">#</a> 6. TCP 关闭连接（四次挥手）</h2> <details class="custom-block details open tip"><summary>点击查看</summary><div class="language- extra-class"><pre><code>&lt;img src=&quot;/img/question/network/tcp4.png&quot; alt=&quot;tcp&quot; title=&quot;tcp&quot; class=&quot;zoom-custom-imgs&quot;&gt;
</code></pre></div><ul><li>第一次挥手：
<ul><li>Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li></ul></li> <li>第二次挥手：
<ul><li>Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li></ul></li> <li>第三次挥手：
<ul><li>Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li></ul></li> <li>第四次挥手：
<ul><li>Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号+1，Server 进入 CLOSED 状态，完成四次挥手。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ul></li></ul></details><h2 id="端口"><a href="#端口" class="header-anchor">#</a> 端口</h2> <details class="custom-block details open tip"><summary>点击查看</summary><p>用来标识同一个主机上通信的不同应用程序</p> <p>一个端口只能分配给一个应用程序，如果服务器有两个程序 A 和 B，分别启动了 A 服务 B 服务，它们监听同一个端口，那有数据来的时候，将无法判断这个数据分给 A 还是 B。</p></details></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/question/0/click.html" class="prev">
        点击穿透问题
      </a></span> <span class="next"><a href="/question/4/response.html">
        ✨ Response Header
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.eb836ae3.js" defer></script><script src="/assets/js/2.ae751d9e.js" defer></script><script src="/assets/js/41.36a1ba26.js" defer></script>
  </body>
</html>
